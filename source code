#include <Arduino.h>
#include <EEPROM.h>
#include <RDA5807.h> // It is a minimal receicer with two push buttons (ATmega328 - Uno, Nano etc)
RDA5807 rx; 
#include <AceCommon.h> // incrementMod()
#include <AceSPI.h>
#include <AceSegment.h> // HybridModule
#include <Tiny4kOLED.h>

//#define DEBUG_ON

#define VOLUME_UP A1
#define VOLUME_DOWN A0
#define FREQUENCY_UP A3
#define FREQUENCY_DOWN A2
#define SEEK_UP 9
#define SEEK_DOWN 8

const uint8_t app_id = 43;  // Useful to check the EEPROM content before processing useful data
const int eeprom_address = 0;
long storeTime = millis();
long storeTime2 = millis();
long storeTime3 = millis();
long storeTime4 = millis();

bool digitsMode = true;
bool digit4state = false;
uint16_t pushcount = 0;
uint16_t pushcount2 = 0;
uint16_t count3 = 0;
uint16_t pushcount4 = 0;

long elapsedRSSI = millis();

const char* RadioStation = "";

#if defined(ARDUINO_ARCH_AVR) || defined(EPOXY_DUINO)
#include <digitalWriteFast.h>
#include <ace_spi/HardSpiFastInterface.h>
#include <ace_spi/SimpleSpiFastInterface.h>
#endif

using ace_common::incrementMod;
using ace_common::incrementModOffset;
using ace_common::TimingStats;
using ace_spi::SimpleSpiInterface;
using ace_spi::HardSpiInterface;
using ace_spi::SimpleSpiFastInterface;
using ace_spi::HardSpiFastInterface;
using ace_segment::LedModule;
using ace_segment::HybridModule;
using ace_segment::kActiveHighPattern;

#define INTERFACE_TYPE_SIMPLE_SPI 0
#define INTERFACE_TYPE_SIMPLE_SPI_FAST 1
#define INTERFACE_TYPE_HARD_SPI 2
#define INTERFACE_TYPE_HARD_SPI_FAST 3
#define INTERFACE_TYPE_SIMPLE_TMI 4
#define INTERFACE_TYPE_SIMPLE_TMI_FAST 5

#define DEFAULT_VOLUME 6
#define STORE_TIME  10    // Time of inactivity to make the current receiver status writable (10s / 10000 milliseconds).
#define STORE_TIME2 10000
#define STORE_TIME3 1000
#define STORE_TIME4 200

#if ! defined(EPOXY_DUINO) && ! defined(AUNITER)
  #define AUNITER_MICRO_CUSTOM_SINGLE
#endif

#if defined(EPOXY_DUINO)
  #define INTERFACE_TYPE INTERFACE_TYPE_HARD_SPI_FAST
  SPIClass& spiInstance = SPI;

#elif defined(AUNITER_MICRO_CUSTOM_SINGLE)
  #define INTERFACE_TYPE INTERFACE_TYPE_HARD_SPI_FAST
  SPIClass& spiInstance = SPI;

#else
  #error Unknown environment
#endif

uint8_t width = 128;
uint8_t height = 64;

const uint8_t NUM_DIGITS = 5;
const uint8_t NUM_SEGMENTS = 8;
const uint8_t LATCH_PIN = 10;
const uint8_t DATA_PIN = MOSI;
const uint8_t CLOCK_PIN = SCK;
const uint8_t DIGIT_PINS[NUM_DIGITS] = {5, 4, 3, 2, 6}; // ケタの順番を修正
const uint8_t COLON_PIN = 6; // コロンのピンを追加

const uint8_t FRAMES_PER_SECOND = 60;
const uint8_t NUM_SUBFIELDS = 16;

uint16_t currentFrequency;
uint16_t previousFrequency;
uint16_t previousFrequency2;
uint16_t previousVolume2;
uint16_t currentVolume;
uint16_t previousVolume;

uint8_t seekDirection = 1;

uint8_t rssi = 0;
uint8_t volume = DEFAULT_VOLUME;

uint16_t STC;

#if INTERFACE_TYPE == INTERFACE_TYPE_SIMPLE_SPI
  using SpiInterface = SimpleSpiInterface;
  SpiInterface spiInterface(LATCH_PIN, DATA_PIN, CLOCK_PIN);
#elif INTERFACE_TYPE == INTERFACE_TYPE_SIMPLE_SPI_FAST
  using SpiInterface = SimpleSpiFastInterface<LATCH_PIN, DATA_PIN, CLOCK_PIN>;
  SpiInterface spiInterface;
#elif INTERFACE_TYPE == INTERFACE_TYPE_HARD_SPI
  using SpiInterface = HardSpiInterface<SPIClass>;
  SpiInterface spiInterface(spiInstance, LATCH_PIN);
#elif INTERFACE_TYPE == INTERFACE_TYPE_HARD_SPI_FAST
  using SpiInterface = HardSpiFastInterface<SPIClass, LATCH_PIN>;
  SpiInterface spiInterface(spiInstance);
#else
  #error Unknown INTERFACE_TYPE
#endif

HybridModule<SpiInterface, NUM_DIGITS, NUM_SUBFIELDS> ledModule(
    spiInterface,
    kActiveHighPattern /*segmentOnPattern*/,
    kActiveHighPattern /*digitOnPattern*/,
    FRAMES_PER_SECOND,
    DIGIT_PINS
);

const uint8_t PATTERNS[26] = {
  0b00111111, // 0
  0b00000110, // 1
  0b01011011, // 2
  0b01001111, // 3
  0b01100110, // 4
  0b01101101, // 5
  0b01111101, // 6
  0b00000111, // 7
  0b01111111, // 8
  0b01101111, // 9
  0b10111111, // 0.
  0b10000110, // 1.
  0b11011011, // 2.
  0b11001111, // 3.
  0b11100110, // 4.
  0b11101101, // 5.
  0b11111101, // 6.
  0b10000111, // 7.
  0b11111111, // 8.
  0b11101111, // 9.
  0b00000001, // : upper single dot (20)
  0b00000010, // : lower single dot (21)
  0b00000011, // : (22)
  0b00000100, // ' (23)
  0b00000111, // :'(24)
  0b00000000  // blank (25)
};

void setupAceSegment() {
#if INTERFACE_TYPE == INTERFACE_TYPE_HARD_SPI \
    || INTERFACE_TYPE == INTERFACE_TYPE_HARD_SPI_FAST
  spiInstance.begin();
#endif

  spiInterface.begin();
  ledModule.begin();
  pinMode(COLON_PIN, OUTPUT);
  digitalWrite(COLON_PIN, LOW);
}

void sevenSegmentDisplay() {
  currentVolume = rx.getVolume();
  uint8_t digits[NUM_DIGITS];
  
  if (digitsMode == true){
    digits[0] = (currentFrequency / 1000) % 10;
    digits[1] = (currentFrequency / 100) % 10 + 10;
    digits[2] = (currentFrequency / 10) % 10;
    digits[3] = currentVolume % 10;
    if (currentVolume > 9) digits[4] = 23;
    else digits[4] = 25;
  }
  else if (digitsMode == false){
    for (int i=0;i<=3;i++){
      digits[i] = 25;
    }
  }

  if (digit4state == true){
    if (currentVolume > 9){
      digits[4] = 24;
    }
    else digits[4] = 22;
    if ((millis() - storeTime) > STORE_TIME3) {
    storeTime = millis();
    digit4state = false;
    }
  }

  if (digit4state == false){
    if (currentVolume > 9){
      digits[4] = 23;
    }
    else digits[4] = 25;
  }
  
  for (uint8_t i = 0; i < NUM_DIGITS; ++i) {
    uint8_t pattern = PATTERNS[digits[i]];
    ledModule.setPatternAt(i, pattern);
  }
  ledModule.renderFieldWhenReady();
/*
  if (seekDirection = 0){
    currentFrequency -= 0.1;
  }

  if (seekDirection = 1){
    currentFrequency += 0.1;
  }*/
}

void showFrequency() {
  currentFrequency = rx.getFrequency();
  switch(currentFrequency) {
    case 7890:     //"1234567890123456"
      RadioStation = "  Shonan BeachFM";
      break;
    case 8000:     //"1234567890123456"
      RadioStation = "        Tokyo FM";
      break;
    case 8130:     //"1234567890123456"
      RadioStation = "          J-wave";
      break;
    case 8190:     //"1234567890123456"
      RadioStation = "          NHK-FM";
      break;
    case 8250:     //"1234567890123456"
      RadioStation = "          NHK-FM";
      break;
    case 8280:     //"1234567890123456"
      RadioStation = "      KamakuraFM";
      break;
    case 8310:     //"1234567890123456"
      RadioStation = "    radio Shonan";
      break;
    case 8370:     //"1234567890123456"
      RadioStation = "      FM-Totsuka";
      break;
    case 8470:     //"1234567890123456"
      RadioStation = "     FM-Yokohama";
      break;
    case 8700:     //"1234567890123456"
      RadioStation = "     FM-Yokohama";
      break;
    case 8970:     //"1234567890123456"
      RadioStation = "         interFM";
      break;
    case 9050:     //"1234567890123456"
      RadioStation = "       TBS radio";
      break;
    case 9160:     //"1234567890123456"
      RadioStation = "    Bunka Housou";
      break;
    case 9240:     //"1234567890123456"
      RadioStation = "    Radio Nippon";
      break;
    case 9300:     //"1234567890123456"
      RadioStation = "   Nippon Housou";
      break;
    default:       //"1234567890123456"
      RadioStation = "         no Data";
  }
}

void showStatus()
{
  oled.setCursor(0, 0);
  oled.print("FM ");
  oled.setCursor(38, 0);
  oled.print("      ");
  oled.setCursor(38, 0);
  oled.print(rx.getRealFrequency() / 100.0);
  oled.setCursor(95, 0);
  oled.print("MHz");
  oled.setCursor(0, 2);
  /*
  oled.print("Volume");
  oled.setCursor(60, 2);
  oled.print("      ");
  oled.setCursor(60, 2);
  oled.print(rx.getVolume());
              KamakuraFM  */
  oled.print(RadioStation);
  oled.setCursor(0, 4);
  oled.print("Volume");
  oled.setCursor(60, 4);
  oled.print("  ");
  oled.setCursor(60, 4);
  oled.print(currentVolume);
}

void saveAllReceiverInformation() {
  EEPROM.update(eeprom_address, app_id);
  EEPROM.update(eeprom_address + 1, rx.getVolume());           // stores the current Volume
  EEPROM.update(eeprom_address + 2, currentFrequency >> 8);    // stores the current Frequency HIGH byte for the band
  EEPROM.update(eeprom_address + 3, currentFrequency & 0xFF);  // stores the current Frequency LOW byte for the band

  digit4state = true;
}

void readAllReceiverInformation() {
  rx.setVolume(EEPROM.read(eeprom_address + 1));
  currentFrequency = EEPROM.read(eeprom_address + 2) << 8;
  currentFrequency |= EEPROM.read(eeprom_address + 3);
  previousFrequency = currentFrequency;
  rx.setFrequency(currentFrequency);
}

void saveInformation(){
  if (((currentFrequency = rx.getFrequency()) != previousFrequency) || (currentVolume != previousVolume)) {
      if ((millis() - storeTime) > STORE_TIME2) {
        count3++;
        if (count3 > 100){
          count3 = 0;
          saveAllReceiverInformation();
          storeTime = millis();
          previousFrequency = currentFrequency;
          previousVolume = currentVolume;
      }
    }
  }
  else count3 = 0;
}

void setup() {
#ifdef DEBUG_ON
  Serial.begin(115200);
#endif
  oled.begin(128, 64, sizeof(tiny4koled_init_128x64), tiny4koled_init_128x64);
  oled.setRotation(1);
  oled.clear();
  oled.on();
  oled.setFont(FONT8X16);
  oled.setCursor(0, 0);
  oled.print("Arduino Radio");
  oled.setCursor(0, 2);
  oled.print("By Kent Kimura");
  rx.setup(); // Starts the receiver with default parameters
  delay(200);
  rx.setBand(RDA_FM_BAND_WORLD);
  rx.setVolume(DEFAULT_VOLUME);
  if (EEPROM.read(eeprom_address) == app_id) {
    readAllReceiverInformation();
  }
  setupAceSegment();
  pinMode(VOLUME_UP, INPUT_PULLUP);
  pinMode(VOLUME_DOWN, INPUT_PULLUP);
  pinMode(FREQUENCY_UP, INPUT_PULLUP);
  pinMode(FREQUENCY_DOWN, INPUT_PULLUP);
  pinMode(SEEK_UP, INPUT_PULLUP);
  pinMode(SEEK_DOWN, INPUT_PULLUP);
  pinMode(2, INPUT);
  pinMode(3, INPUT);
  pinMode(4, INPUT);
  pinMode(5, INPUT);
  pinMode(6, INPUT);
  delay(500);
  oled.clear();
  showFrequency();
  showStatus();
}

void loop() {
  #ifdef DEBUG_ON
  Serial.print( " pushcount = " );
  Serial.println(pushcount);
#endif

  sevenSegmentDisplay();
  saveInformation();
  readButton();

  if (( currentFrequency != previousFrequency2 ) || (currentVolume != previousVolume2)){
    showStatus();
    previousFrequency2 = currentFrequency;
    previousVolume2 = currentVolume;
  }
}

void readButton(){
    if (digitalRead(FREQUENCY_DOWN) == LOW) {
    if ((millis() - storeTime) > STORE_TIME) {
      storeTime = millis();//      rx.setFrequencyDown();
      pushcount++;
      if (pushcount > 3){
        pushcount = 0;
        rx.setFrequencyDown();
        showFrequency();
      }
    }
  }

  if (digitalRead(FREQUENCY_UP) == LOW) {
    if ((millis() - storeTime) > STORE_TIME) {
      storeTime = millis();
      pushcount++;
      if (pushcount > 3){
        pushcount = 0;
        rx.setFrequencyUp();
        showFrequency();
      }
    } 
  }

  if ((digitalRead(FREQUENCY_DOWN) == HIGH) && (digitalRead(FREQUENCY_UP) == HIGH)){
    pushcount2++;
    if (pushcount2 > 10) {
      pushcount2 = 0;
      pushcount = 0;
    }
  }


  if (digitalRead(VOLUME_DOWN) == LOW) {
    if ((millis() - storeTime4) > STORE_TIME4) {
      storeTime4 = millis();
      pushcount4++;
      if (pushcount4 > 10){
        pushcount4 = 0;
//        digitsMode = !digitsMode; //7セグ表示オフ
      }
      rx.setVolumeDown();
    }
  }

  if (digitalRead(VOLUME_UP) == LOW) {
    if ((millis() - storeTime4) > STORE_TIME4) {
      storeTime4 = millis();
      rx.setVolumeUp();
    }
  }

  if (digitalRead(SEEK_UP) == LOW) {
    if ((millis() - storeTime) > STORE_TIME) {
      storeTime = millis();//      rx.setFrequencyDown();
      pushcount4++;
      if (pushcount4 > 3){
        pushcount4 = 0;
        seekDirection = RDA_SEEK_UP;
        rx.seek(RDA_SEEK_WRAP,RDA_SEEK_UP, showFrequency);
      }
    }
  }

  if (digitalRead(SEEK_DOWN) == LOW) {
    if ((millis() - storeTime) > STORE_TIME) {
      storeTime = millis();//      rx.setFrequencyDown();
      pushcount4++;
      if (pushcount4 > 3){
        pushcount4 = 0;
        seekDirection = RDA_SEEK_DOWN;
        rx.seek(RDA_SEEK_WRAP,RDA_SEEK_DOWN, showFrequency);
      }
    }
  }
}
